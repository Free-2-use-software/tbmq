#
# Copyright Â© 2016-2020 The Thingsboard Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

server:
  # Server bind address (has no effect if web-environment is disabled).
  address: "${HTTP_BIND_ADDRESS:0.0.0.0}"
  # Server bind port (has no effect if web-environment is disabled).
  port: "${HTTP_BIND_PORT:8083}"
  log_controller_error_stack_trace: "${HTTP_LOG_CONTROLLER_ERROR_STACK_TRACE:false}"
  # Server SSL configuration
  ssl:
    # Enable/disable SSL support
    enabled: "${SSL_ENABLED:false}"
    # Path to the key store that holds the SSL certificate
    key-store: "${SSL_KEY_STORE:classpath:keystore/keystore.p12}"
    # Password used to access the key store
    key-store-password: "${SSL_KEY_STORE_PASSWORD:thingsboard_mqtt_broker}"
    # Type of the key store
    key-store-type: "${SSL_KEY_STORE_TYPE:PKCS12}"
    # Alias that identifies the key in the key store
    key-alias: "${SSL_KEY_ALIAS:tomcat}"

listener:
  # MQTT server parameters
  tcp:
    enabled: "${LISTENER_TCP_ENABLED:true}"
    bind_address: "${LISTENER_TCP_BIND_ADDRESS:0.0.0.0}"
    bind_port: "${LISTENER_TCP_BIND_PORT:1883}"
    netty:
      leak_detector_level: "${TCP_NETTY_LEAK_DETECTOR_LVL:DISABLED}"
      boss_group_thread_count: "${TCP_NETTY_BOSS_GROUP_THREADS:1}"
      worker_group_thread_count: "${TCP_NETTY_WORKER_GROUP_THREADS:12}"
      max_payload_size: "${TCP_NETTY_MAX_PAYLOAD_SIZE:65536}"
  ssl:
    enabled: "${LISTENER_SSL_ENABLED:true}"
    bind_address: "${LISTENER_SSL_BIND_ADDRESS:0.0.0.0}"
    bind_port: "${LISTENER_SSL_BIND_PORT:8883}"
    config:
      # SSL protocol: See http://docs.oracle.com/javase/8/docs/technotes/guides/security/StandardNames.html#SSLContext
      protocol: "${LISTENER_SSL_PROTOCOL:TLSv1.2}"
      # Path to the key store that holds the SSL certificate
      key_store: "${LISTENER_SSL_KEY_STORE:mqtt_server.jks}"
      # Password used to access the key store
      key_store_password: "${LISTENER_SSL_KEY_STORE_PASSWORD:keystore_password}"
      # Password used to access the key
      key_password: "${LISTENER_SSL_KEY_PASSWORD:key_password}"
      # Type of the key store
      key_store_type: "${LISTENER_SSL_KEY_STORE_TYPE:JKS}"
      # Path to the trust store that holds the SSL certificate
      trust_store: "${LISTENER_SSL_TRUST_STORE:root_truststore.jks}"
      # Password used to access the trust store
      trust_store_password: "${LISTENER_SSL_TRUST_STORE_PASSWORD:truststore_password}"
      # Type of the trust store
      trust_store_type: "${SECURITY_MQTT_SSL_TRUST_STORE_TYPE:JKS}"
    netty:
      leak_detector_level: "${SSL_NETTY_LEAK_DETECTOR_LVL:DISABLED}"
      boss_group_thread_count: "${SSL_NETTY_BOSS_GROUP_THREADS:1}"
      worker_group_thread_count: "${SSL_NETTY_WORKER_GROUP_THREADS:12}"
      max_payload_size: "${SSL_NETTY_MAX_PAYLOAD_SIZE:65536}"

queue:
  publish-msg:
    # Number of parallel consumers for 'publish-msg' topic. Should not be more than the number of partitions in topic.
    consumers-count: "${TB_PUBLISH_MSG_CONSUMERS_COUNT:2}"
    poll-interval: "${TB_PUBLISH_MSG_POLL_INTERVAL:100}"
  application-persisted-msg:
    poll-interval: "${TB_APP_PERSISTED_MSG_POLL_INTERVAL:100}"
    pack-processing-timeout: "${TB_APP_PERSISTED_MSG_PACK_PROCESSING_TIMEOUT:2000}"
    ack-strategy:
      type: "${TB_APP_PERSISTED_MSG_ACK_STRATEGY_TYPE:SKIP_ALL}" # SKIP_ALL, RETRY_ALL
      # For RETRY_ALL only
      retries: "${TB_APP_PERSISTED_MSG_ACK_STRATEGY_RETRIES:1}"
  application-publish-ctx:
    poll-interval: "${TB_APP_PUBLISH_CTX_POLL_INTERVAL:100}"
  client-session:
    poll-interval: "${TB_CLIENT_SESSION_POLL_INTERVAL:100}"
    acknowledge-wait-timeout-ms: "${TB_CLIENT_SESSION_ACK_WAIT_TIMEOUT_MS:500}"
  kafka:
    bootstrap.servers: "${TB_KAFKA_SERVERS:localhost:9092}"
    topic-properties:
      publish-msg: "${TB_KAFKA_PUBLISH_MSG_TOPIC_PROPERTIES:retention.ms:604800000;segment.bytes:26214400;retention.bytes:1048576000;partitions:10;replication.factor:1}"
      # Configure retention policy according to the persistence requirements for APPLICATION clients
      application-persistence-msg: "${TB_KAFKA_APP_PERSISTENCE_MSG_TOPIC_PROPERTIES:retention.ms:604800000;segment.bytes:26214400;retention.bytes:1048576000;replication.factor:1}"
      application-publish-ctx: "${TB_KAFKA_APP_PUBLISH_CTX_TOPIC_PROPERTIES:segment.bytes:26214400;partitions:1;replication.factor:1}"
      client-session: "${TB_KAFKA_CLIENT_SESSION_TOPIC_PROPERTIES:segment.bytes:26214400;partitions:1;replication.factor:1}"
    publish-msg:
      topic: "${TB_KAFKA_PUBLISH_MSG_TOPIC:publish_msg}"
      producer:
        acks: "${TB_KAFKA_PUBLISH_MSG_ACKS:all}"
        retries: "${TB_KAFKA_PUBLISH_MSG_RETRIES:1}"
        batchSize: "${TB_KAFKA_PUBLISH_MSG_BATCH_SIZE:16384}"
        lingerMs: "${TB_KAFKA_PUBLISH_MSG_LINGER_MS:1}"
        bufferMemory: "${TB_KAFKA_PUBLISH_MSG_BUFFER_MEMORY:33554432}"
      consumer:
        maxPollIntervalMs: "${TB_KAFKA_PUBLISH_MSG_MAX_POLL_INTERVAL_MS:0}"
        maxPollRecords: "${TB_KAFKA_PUBLISH_MSG_MAX_POLL_RECORDS:8192}"
        maxPartitionFetchBytes: "${TB_KAFKA_PUBLISH_MSG_MAX_PARTITION_FETCH_BYTES:16777216}"
        fetchMaxBytes: "${TB_KAFKA_PUBLISH_MSG_FETCH_MAX_BYTES:134217728}"
    application-persistence-msg:
      producer:
        acks: "${TB_KAFKA_APP_PERSISTENCE_MSG_ACKS:1}"
        retries: "${TB_KAFKA_APP_PERSISTENCE_MSG_RETRIES:1}"
        batchSize: "${TB_KAFKA_APP_PERSISTENCE_MSG_BATCH_SIZE:16384}"
        lingerMs: "${TB_KAFKA_APP_PERSISTENCE_MSG_LINGER_MS:1}"
        bufferMemory: "${TB_KAFKA_APP_PERSISTENCE_MSG_BUFFER_MEMORY:33554432}"
      consumer:
        maxPollIntervalMs: "${TB_KAFKA_APP_PERSISTENCE_MSG_MAX_POLL_INTERVAL_MS:0}"
        maxPollRecords: "${TB_KAFKA_APP_PERSISTENCE_MSG_MAX_POLL_RECORDS:8192}"
        maxPartitionFetchBytes: "${TB_KAFKA_APP_PERSISTENCE_MSG_MAX_PARTITION_FETCH_BYTES:16777216}"
        fetchMaxBytes: "${TB_KAFKA_APP_PERSISTENCE_MSG_FETCH_MAX_BYTES:134217728}"
      other:
        - key: "auto.offset.reset"
          value: "earliest"
    application-publish-ctx:
      topic: "${TB_KAFKA_APP_PUBLISH_CTX_TOPIC:latest_publish_ctx}"
      producer:
        acks: "${TB_KAFKA_APP_PUBLISH_CTX_ACKS:1}"
        retries: "${TB_KAFKA_APP_PUBLISH_CTX_RETRIES:1}"
        batchSize: "${TB_KAFKA_APP_PUBLISH_CTX_BATCH_SIZE:16384}"
        lingerMs: "${TB_KAFKA_APP_PUBLISH_CTX_LINGER_MS:1}"
        bufferMemory: "${TB_KAFKA_APP_PUBLISH_CTX_BUFFER_MEMORY:33554432}"
      consumer:
        maxPollIntervalMs: "${TB_KAFKA_APP_PUBLISH_CTX_MAX_POLL_INTERVAL_MS:0}"
        maxPollRecords: "${TB_KAFKA_APP_PUBLISH_CTX_MAX_POLL_RECORDS:8192}"
        maxPartitionFetchBytes: "${TB_KAFKA_APP_PUBLISH_CTX_MAX_PARTITION_FETCH_BYTES:16777216}"
        fetchMaxBytes: "${TB_KAFKA_APP_PUBLISH_CTX_FETCH_MAX_BYTES:134217728}"
    client-session:
      topic: "${TB_KAFKA_CLIENT_SESSION_TOPIC:client_session}"
      producer:
        # Should be 'all' so that there's no inconsistency in client's subscriptions
        acks: "${TB_KAFKA_CLIENT_SESSION_ACKS:all}"
        retries: "${TB_KAFKA_CLIENT_SESSION_RETRIES:3}"
        batchSize: "${TB_KAFKA_CLIENT_SESSION_BATCH_SIZE:16384}"
        lingerMs: "${TB_KAFKA_CLIENT_SESSION_LINGER_MS:1}"
        bufferMemory: "${TB_KAFKA_CLIENT_SESSION_BUFFER_MEMORY:33554432}"
      consumer:
        maxPollIntervalMs: "${TB_KAFKA_CLIENT_SESSION_MAX_POLL_INTERVAL_MS:0}"
        maxPollRecords: "${TB_KAFKA_CLIENT_SESSION_MAX_POLL_RECORDS:8192}"
        maxPartitionFetchBytes: "${TB_KAFKA_CLIENT_SESSION_MAX_PARTITION_FETCH_BYTES:16777216}"
        fetchMaxBytes: "${TB_KAFKA_CLIENT_SESSION_FETCH_MAX_BYTES:134217728}"

# SQL DAO Configuration
spring:
  data:
    jpa:
      repositories:
        enabled: "true"
  jpa:
    open-in-view: "false"
    hibernate:
      ddl-auto: "none"
    database-platform: "${SPRING_JPA_DATABASE_PLATFORM:org.hibernate.dialect.PostgreSQLDialect}"
  datasource:
    driverClassName: "${SPRING_DRIVER_CLASS_NAME:org.postgresql.Driver}"
    url: "${SPRING_DATASOURCE_URL:jdbc:postgresql://localhost:5432/thingsboard_mqtt_broker}"
    username: "${SPRING_DATASOURCE_USERNAME:postgres}"
    password: "${SPRING_DATASOURCE_PASSWORD:postgres}"
    hikari:
      maximumPoolSize: "${SPRING_DATASOURCE_MAXIMUM_POOL_SIZE:16}"

spring.jpa.properties.hibernate.jdbc.lob.non_contextual_creation: "true"
spring.jpa.properties.hibernate.order_by.default_null_ordering: "last"

# spring CORS configuration
spring.mvc.cors:
  mappings:
    # Intercept path
    "[/api/**]":
      #Comma-separated list of origins to allow. '*' allows all origins. When not set,CORS support is disabled.
      allowed-origins: "*"
      #Comma-separated list of methods to allow. '*' allows all methods.
      allowed-methods: "*"
      #Comma-separated list of headers to allow in a request. '*' allows all headers.
      allowed-headers: "*"
      #How long, in seconds, the response from a pre-flight request can be cached by clients.
      max-age: "1800"
      #Set whether credentials are supported. When not set, credentials are not supported.
      allow-credentials: "true"

# Security parameters
security:
  mqtt:
    basic:
      # If enabled the server will try to authenticate client with clientId and/or username and/or password
      enabled: "${SECURITY_MQTT_BASIC_ENABLED:false}"
    ssl:
      # If enabled the server will try to authenticate client with client certificate chain
      enabled: "${SECURITY_MQTT_SSL_ENABLED:false}"
  # JWT Token parameters
  jwt:
    tokenExpirationTime: "${JWT_TOKEN_EXPIRATION_TIME:9000}" # Number of seconds (2.5 hours)
    refreshTokenExpTime: "${JWT_REFRESH_TOKEN_EXPIRATION_TIME:604800}" # Number of seconds (1 week)
    tokenIssuer: "${JWT_TOKEN_ISSUER:thingsboard.io}"
    tokenSigningKey: "${JWT_TOKEN_SIGNING_KEY:thingsboardDefaultSigningKey}"
  # Enable/disable case-sensitive username login
  user_login_case_sensitive: "${SECURITY_USER_LOGIN_CASE_SENSITIVE:true}"


application:
  mqtt:
    keep-alive:
      # Schedule monitoring for inactive MQTT clients
      monitoring-delay-ms: "${APPLICATION_MQTT_KEEP_ALIVE_MONITORING_DELAY_MS:100}"
    topic:
      max-segments-count: "${APPLICATION_MQTT_TOPIC_MAX_SEGMENTS_COUNT:6000}"
    subscription-trie:
      # Wait for clients to pause subscribing to topics so that application can clear SubscriptionTrie.
      # If wait is unsuccessful the subscribing clients will be resumed, but the clear will fail.
      wait-for-clear-lock-ms: "${APPLICATION_MQTT_SUB_TRIE_WAIT_FOR_CLEAR_LOCK_MS:100}"
      # Cron specification when to run clearing empty nodes. Defaults to 'never'
      clear-nodes-cron: "${APPLICATION_MQTT_SUB_TRIE_CLEAR_NODES_CRON:-}"
      clear-nodes-zone: "${APPLICATION_MQTT_SUB_TRIE_CLEAR_NODES_ZONE:UTC}"

stats:
  enabled: "${STATS_ENABLED:true}"
  print-interval-ms: "${STATS_PRINT_INTERVAL_MS:60000}"

management:
  endpoints:
    web:
      exposure:
        # Expose metrics endpoint (use value 'prometheus' to enable prometheus metrics).
        include: '${METRICS_ENDPOINTS_EXPOSE:info}'

swagger:
  api_path_regex: "${SWAGGER_API_PATH_REGEX:/api.*}"
  security_path_regex: "${SWAGGER_SECURITY_PATH_REGEX:/api.*}"
  non_security_path_regex: "${SWAGGER_NON_SECURITY_PATH_REGEX:/api/noauth.*}"
  title: "${SWAGGER_TITLE:ThingsBoard MQTT Broker REST API}"
  description: "${SWAGGER_DESCRIPTION:}"
  contact:
    name: "${SWAGGER_CONTACT_NAME:Thingsboard team}"
    url: "${SWAGGER_CONTACT_URL:http://thingsboard.io}"
    email: "${SWAGGER_CONTACT_EMAIL:info@thingsboard.io}"
  license:
    title: "${SWAGGER_LICENSE_TITLE:}"
    url: "${SWAGGER_LICENSE_URL:}"
  version: "${SWAGGER_VERSION:2.0}"